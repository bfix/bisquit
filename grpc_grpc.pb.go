// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package bisquit

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DisputeAgentsClient is the client API for DisputeAgents service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DisputeAgentsClient interface {
	// Register regtest / dev mode dispute agents.  Does not work when running on mainnet.
	RegisterDisputeAgent(ctx context.Context, in *RegisterDisputeAgentRequest, opts ...grpc.CallOption) (*RegisterDisputeAgentReply, error)
}

type disputeAgentsClient struct {
	cc grpc.ClientConnInterface
}

func NewDisputeAgentsClient(cc grpc.ClientConnInterface) DisputeAgentsClient {
	return &disputeAgentsClient{cc}
}

func (c *disputeAgentsClient) RegisterDisputeAgent(ctx context.Context, in *RegisterDisputeAgentRequest, opts ...grpc.CallOption) (*RegisterDisputeAgentReply, error) {
	out := new(RegisterDisputeAgentReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.DisputeAgents/RegisterDisputeAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DisputeAgentsServer is the server API for DisputeAgents service.
// All implementations must embed UnimplementedDisputeAgentsServer
// for forward compatibility
type DisputeAgentsServer interface {
	// Register regtest / dev mode dispute agents.  Does not work when running on mainnet.
	RegisterDisputeAgent(context.Context, *RegisterDisputeAgentRequest) (*RegisterDisputeAgentReply, error)
	mustEmbedUnimplementedDisputeAgentsServer()
}

// UnimplementedDisputeAgentsServer must be embedded to have forward compatible implementations.
type UnimplementedDisputeAgentsServer struct {
}

func (UnimplementedDisputeAgentsServer) RegisterDisputeAgent(context.Context, *RegisterDisputeAgentRequest) (*RegisterDisputeAgentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDisputeAgent not implemented")
}
func (UnimplementedDisputeAgentsServer) mustEmbedUnimplementedDisputeAgentsServer() {}

// UnsafeDisputeAgentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DisputeAgentsServer will
// result in compilation errors.
type UnsafeDisputeAgentsServer interface {
	mustEmbedUnimplementedDisputeAgentsServer()
}

func RegisterDisputeAgentsServer(s grpc.ServiceRegistrar, srv DisputeAgentsServer) {
	s.RegisterService(&DisputeAgents_ServiceDesc, srv)
}

func _DisputeAgents_RegisterDisputeAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDisputeAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisputeAgentsServer).RegisterDisputeAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.DisputeAgents/RegisterDisputeAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisputeAgentsServer).RegisterDisputeAgent(ctx, req.(*RegisterDisputeAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DisputeAgents_ServiceDesc is the grpc.ServiceDesc for DisputeAgents service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DisputeAgents_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.DisputeAgents",
	HandlerType: (*DisputeAgentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDisputeAgent",
			Handler:    _DisputeAgents_RegisterDisputeAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// HelpClient is the client API for Help service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HelpClient interface {
	// Returns a CLI command man page.
	GetMethodHelp(ctx context.Context, in *GetMethodHelpRequest, opts ...grpc.CallOption) (*GetMethodHelpReply, error)
}

type helpClient struct {
	cc grpc.ClientConnInterface
}

func NewHelpClient(cc grpc.ClientConnInterface) HelpClient {
	return &helpClient{cc}
}

func (c *helpClient) GetMethodHelp(ctx context.Context, in *GetMethodHelpRequest, opts ...grpc.CallOption) (*GetMethodHelpReply, error) {
	out := new(GetMethodHelpReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Help/GetMethodHelp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HelpServer is the server API for Help service.
// All implementations must embed UnimplementedHelpServer
// for forward compatibility
type HelpServer interface {
	// Returns a CLI command man page.
	GetMethodHelp(context.Context, *GetMethodHelpRequest) (*GetMethodHelpReply, error)
	mustEmbedUnimplementedHelpServer()
}

// UnimplementedHelpServer must be embedded to have forward compatible implementations.
type UnimplementedHelpServer struct {
}

func (UnimplementedHelpServer) GetMethodHelp(context.Context, *GetMethodHelpRequest) (*GetMethodHelpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMethodHelp not implemented")
}
func (UnimplementedHelpServer) mustEmbedUnimplementedHelpServer() {}

// UnsafeHelpServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HelpServer will
// result in compilation errors.
type UnsafeHelpServer interface {
	mustEmbedUnimplementedHelpServer()
}

func RegisterHelpServer(s grpc.ServiceRegistrar, srv HelpServer) {
	s.RegisterService(&Help_ServiceDesc, srv)
}

func _Help_GetMethodHelp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMethodHelpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelpServer).GetMethodHelp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Help/GetMethodHelp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelpServer).GetMethodHelp(ctx, req.(*GetMethodHelpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Help_ServiceDesc is the grpc.ServiceDesc for Help service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Help_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Help",
	HandlerType: (*HelpServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMethodHelp",
			Handler:    _Help_GetMethodHelp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// OffersClient is the client API for Offers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OffersClient interface {
	// Get an offer's category, one of  FIAT, ALTCOIN, or BSQ_SWAP.  This information is needed before an offer
	// can be taken, and is used by a client to determine what kind of offer to take:  a v1 FIAT or ALTCOIN offer,
	// or a BSQ swap offer.  V1 and BSQ swap trades are handled differently in the API daemon.
	GetOfferCategory(ctx context.Context, in *GetOfferCategoryRequest, opts ...grpc.CallOption) (*GetOfferCategoryReply, error)
	// Get the available BSQ swap offer with offer-id.
	GetBsqSwapOffer(ctx context.Context, in *GetOfferRequest, opts ...grpc.CallOption) (*GetBsqSwapOfferReply, error)
	// Get the v1 protocol offer with offer-id.
	GetOffer(ctx context.Context, in *GetOfferRequest, opts ...grpc.CallOption) (*GetOfferReply, error)
	// Get user's BSQ swap offer with offer-id.
	GetMyBsqSwapOffer(ctx context.Context, in *GetMyOfferRequest, opts ...grpc.CallOption) (*GetMyBsqSwapOfferReply, error)
	// Get my open v1 protocol offer with offer-id.  Deprecated since 27-Dec-2021 (v1.8.0).  Use GetOffer.
	GetMyOffer(ctx context.Context, in *GetMyOfferRequest, opts ...grpc.CallOption) (*GetMyOfferReply, error)
	// Get all available BSQ swap offers with a BUY (BTC) or SELL (BTC) direction.
	GetBsqSwapOffers(ctx context.Context, in *GetBsqSwapOffersRequest, opts ...grpc.CallOption) (*GetBsqSwapOffersReply, error)
	// Get all available v1 protocol offers with a BUY (BTC) or SELL (BTC) direction.
	GetOffers(ctx context.Context, in *GetOffersRequest, opts ...grpc.CallOption) (*GetOffersReply, error)
	// Get all user's BSQ swap offers with a BUY (BTC) or SELL (BTC) direction.
	GetMyBsqSwapOffers(ctx context.Context, in *GetBsqSwapOffersRequest, opts ...grpc.CallOption) (*GetMyBsqSwapOffersReply, error)
	// Get all user's open v1 protocol offers with a BUY (BTC) or SELL (BTC) direction.
	GetMyOffers(ctx context.Context, in *GetMyOffersRequest, opts ...grpc.CallOption) (*GetMyOffersReply, error)
	// Create a BSQ swap offer.
	CreateBsqSwapOffer(ctx context.Context, in *CreateBsqSwapOfferRequest, opts ...grpc.CallOption) (*CreateBsqSwapOfferReply, error)
	// Create a v1 protocol offer.
	CreateOffer(ctx context.Context, in *CreateOfferRequest, opts ...grpc.CallOption) (*CreateOfferReply, error)
	// Edit an open offer.
	EditOffer(ctx context.Context, in *EditOfferRequest, opts ...grpc.CallOption) (*EditOfferReply, error)
	// Cancel an open offer;  remove it from the offer book.
	CancelOffer(ctx context.Context, in *CancelOfferRequest, opts ...grpc.CallOption) (*CancelOfferReply, error)
}

type offersClient struct {
	cc grpc.ClientConnInterface
}

func NewOffersClient(cc grpc.ClientConnInterface) OffersClient {
	return &offersClient{cc}
}

func (c *offersClient) GetOfferCategory(ctx context.Context, in *GetOfferCategoryRequest, opts ...grpc.CallOption) (*GetOfferCategoryReply, error) {
	out := new(GetOfferCategoryReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetOfferCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetBsqSwapOffer(ctx context.Context, in *GetOfferRequest, opts ...grpc.CallOption) (*GetBsqSwapOfferReply, error) {
	out := new(GetBsqSwapOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetBsqSwapOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetOffer(ctx context.Context, in *GetOfferRequest, opts ...grpc.CallOption) (*GetOfferReply, error) {
	out := new(GetOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetMyBsqSwapOffer(ctx context.Context, in *GetMyOfferRequest, opts ...grpc.CallOption) (*GetMyBsqSwapOfferReply, error) {
	out := new(GetMyBsqSwapOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetMyBsqSwapOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetMyOffer(ctx context.Context, in *GetMyOfferRequest, opts ...grpc.CallOption) (*GetMyOfferReply, error) {
	out := new(GetMyOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetMyOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetBsqSwapOffers(ctx context.Context, in *GetBsqSwapOffersRequest, opts ...grpc.CallOption) (*GetBsqSwapOffersReply, error) {
	out := new(GetBsqSwapOffersReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetBsqSwapOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetOffers(ctx context.Context, in *GetOffersRequest, opts ...grpc.CallOption) (*GetOffersReply, error) {
	out := new(GetOffersReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetMyBsqSwapOffers(ctx context.Context, in *GetBsqSwapOffersRequest, opts ...grpc.CallOption) (*GetMyBsqSwapOffersReply, error) {
	out := new(GetMyBsqSwapOffersReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetMyBsqSwapOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetMyOffers(ctx context.Context, in *GetMyOffersRequest, opts ...grpc.CallOption) (*GetMyOffersReply, error) {
	out := new(GetMyOffersReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetMyOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) CreateBsqSwapOffer(ctx context.Context, in *CreateBsqSwapOfferRequest, opts ...grpc.CallOption) (*CreateBsqSwapOfferReply, error) {
	out := new(CreateBsqSwapOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/CreateBsqSwapOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) CreateOffer(ctx context.Context, in *CreateOfferRequest, opts ...grpc.CallOption) (*CreateOfferReply, error) {
	out := new(CreateOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/CreateOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) EditOffer(ctx context.Context, in *EditOfferRequest, opts ...grpc.CallOption) (*EditOfferReply, error) {
	out := new(EditOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/EditOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) CancelOffer(ctx context.Context, in *CancelOfferRequest, opts ...grpc.CallOption) (*CancelOfferReply, error) {
	out := new(CancelOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/CancelOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OffersServer is the server API for Offers service.
// All implementations must embed UnimplementedOffersServer
// for forward compatibility
type OffersServer interface {
	// Get an offer's category, one of  FIAT, ALTCOIN, or BSQ_SWAP.  This information is needed before an offer
	// can be taken, and is used by a client to determine what kind of offer to take:  a v1 FIAT or ALTCOIN offer,
	// or a BSQ swap offer.  V1 and BSQ swap trades are handled differently in the API daemon.
	GetOfferCategory(context.Context, *GetOfferCategoryRequest) (*GetOfferCategoryReply, error)
	// Get the available BSQ swap offer with offer-id.
	GetBsqSwapOffer(context.Context, *GetOfferRequest) (*GetBsqSwapOfferReply, error)
	// Get the v1 protocol offer with offer-id.
	GetOffer(context.Context, *GetOfferRequest) (*GetOfferReply, error)
	// Get user's BSQ swap offer with offer-id.
	GetMyBsqSwapOffer(context.Context, *GetMyOfferRequest) (*GetMyBsqSwapOfferReply, error)
	// Get my open v1 protocol offer with offer-id.  Deprecated since 27-Dec-2021 (v1.8.0).  Use GetOffer.
	GetMyOffer(context.Context, *GetMyOfferRequest) (*GetMyOfferReply, error)
	// Get all available BSQ swap offers with a BUY (BTC) or SELL (BTC) direction.
	GetBsqSwapOffers(context.Context, *GetBsqSwapOffersRequest) (*GetBsqSwapOffersReply, error)
	// Get all available v1 protocol offers with a BUY (BTC) or SELL (BTC) direction.
	GetOffers(context.Context, *GetOffersRequest) (*GetOffersReply, error)
	// Get all user's BSQ swap offers with a BUY (BTC) or SELL (BTC) direction.
	GetMyBsqSwapOffers(context.Context, *GetBsqSwapOffersRequest) (*GetMyBsqSwapOffersReply, error)
	// Get all user's open v1 protocol offers with a BUY (BTC) or SELL (BTC) direction.
	GetMyOffers(context.Context, *GetMyOffersRequest) (*GetMyOffersReply, error)
	// Create a BSQ swap offer.
	CreateBsqSwapOffer(context.Context, *CreateBsqSwapOfferRequest) (*CreateBsqSwapOfferReply, error)
	// Create a v1 protocol offer.
	CreateOffer(context.Context, *CreateOfferRequest) (*CreateOfferReply, error)
	// Edit an open offer.
	EditOffer(context.Context, *EditOfferRequest) (*EditOfferReply, error)
	// Cancel an open offer;  remove it from the offer book.
	CancelOffer(context.Context, *CancelOfferRequest) (*CancelOfferReply, error)
	mustEmbedUnimplementedOffersServer()
}

// UnimplementedOffersServer must be embedded to have forward compatible implementations.
type UnimplementedOffersServer struct {
}

func (UnimplementedOffersServer) GetOfferCategory(context.Context, *GetOfferCategoryRequest) (*GetOfferCategoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOfferCategory not implemented")
}
func (UnimplementedOffersServer) GetBsqSwapOffer(context.Context, *GetOfferRequest) (*GetBsqSwapOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBsqSwapOffer not implemented")
}
func (UnimplementedOffersServer) GetOffer(context.Context, *GetOfferRequest) (*GetOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOffer not implemented")
}
func (UnimplementedOffersServer) GetMyBsqSwapOffer(context.Context, *GetMyOfferRequest) (*GetMyBsqSwapOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyBsqSwapOffer not implemented")
}
func (UnimplementedOffersServer) GetMyOffer(context.Context, *GetMyOfferRequest) (*GetMyOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyOffer not implemented")
}
func (UnimplementedOffersServer) GetBsqSwapOffers(context.Context, *GetBsqSwapOffersRequest) (*GetBsqSwapOffersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBsqSwapOffers not implemented")
}
func (UnimplementedOffersServer) GetOffers(context.Context, *GetOffersRequest) (*GetOffersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOffers not implemented")
}
func (UnimplementedOffersServer) GetMyBsqSwapOffers(context.Context, *GetBsqSwapOffersRequest) (*GetMyBsqSwapOffersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyBsqSwapOffers not implemented")
}
func (UnimplementedOffersServer) GetMyOffers(context.Context, *GetMyOffersRequest) (*GetMyOffersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyOffers not implemented")
}
func (UnimplementedOffersServer) CreateBsqSwapOffer(context.Context, *CreateBsqSwapOfferRequest) (*CreateBsqSwapOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBsqSwapOffer not implemented")
}
func (UnimplementedOffersServer) CreateOffer(context.Context, *CreateOfferRequest) (*CreateOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOffer not implemented")
}
func (UnimplementedOffersServer) EditOffer(context.Context, *EditOfferRequest) (*EditOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditOffer not implemented")
}
func (UnimplementedOffersServer) CancelOffer(context.Context, *CancelOfferRequest) (*CancelOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOffer not implemented")
}
func (UnimplementedOffersServer) mustEmbedUnimplementedOffersServer() {}

// UnsafeOffersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OffersServer will
// result in compilation errors.
type UnsafeOffersServer interface {
	mustEmbedUnimplementedOffersServer()
}

func RegisterOffersServer(s grpc.ServiceRegistrar, srv OffersServer) {
	s.RegisterService(&Offers_ServiceDesc, srv)
}

func _Offers_GetOfferCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOfferCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetOfferCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetOfferCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetOfferCategory(ctx, req.(*GetOfferCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetBsqSwapOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetBsqSwapOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetBsqSwapOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetBsqSwapOffer(ctx, req.(*GetOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetOffer(ctx, req.(*GetOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetMyBsqSwapOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetMyBsqSwapOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetMyBsqSwapOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetMyBsqSwapOffer(ctx, req.(*GetMyOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetMyOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetMyOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetMyOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetMyOffer(ctx, req.(*GetMyOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetBsqSwapOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBsqSwapOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetBsqSwapOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetBsqSwapOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetBsqSwapOffers(ctx, req.(*GetBsqSwapOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetOffers(ctx, req.(*GetOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetMyBsqSwapOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBsqSwapOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetMyBsqSwapOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetMyBsqSwapOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetMyBsqSwapOffers(ctx, req.(*GetBsqSwapOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetMyOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetMyOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetMyOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetMyOffers(ctx, req.(*GetMyOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_CreateBsqSwapOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBsqSwapOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).CreateBsqSwapOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/CreateBsqSwapOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).CreateBsqSwapOffer(ctx, req.(*CreateBsqSwapOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_CreateOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).CreateOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/CreateOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).CreateOffer(ctx, req.(*CreateOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_EditOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).EditOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/EditOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).EditOffer(ctx, req.(*EditOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_CancelOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).CancelOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/CancelOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).CancelOffer(ctx, req.(*CancelOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Offers_ServiceDesc is the grpc.ServiceDesc for Offers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Offers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Offers",
	HandlerType: (*OffersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOfferCategory",
			Handler:    _Offers_GetOfferCategory_Handler,
		},
		{
			MethodName: "GetBsqSwapOffer",
			Handler:    _Offers_GetBsqSwapOffer_Handler,
		},
		{
			MethodName: "GetOffer",
			Handler:    _Offers_GetOffer_Handler,
		},
		{
			MethodName: "GetMyBsqSwapOffer",
			Handler:    _Offers_GetMyBsqSwapOffer_Handler,
		},
		{
			MethodName: "GetMyOffer",
			Handler:    _Offers_GetMyOffer_Handler,
		},
		{
			MethodName: "GetBsqSwapOffers",
			Handler:    _Offers_GetBsqSwapOffers_Handler,
		},
		{
			MethodName: "GetOffers",
			Handler:    _Offers_GetOffers_Handler,
		},
		{
			MethodName: "GetMyBsqSwapOffers",
			Handler:    _Offers_GetMyBsqSwapOffers_Handler,
		},
		{
			MethodName: "GetMyOffers",
			Handler:    _Offers_GetMyOffers_Handler,
		},
		{
			MethodName: "CreateBsqSwapOffer",
			Handler:    _Offers_CreateBsqSwapOffer_Handler,
		},
		{
			MethodName: "CreateOffer",
			Handler:    _Offers_CreateOffer_Handler,
		},
		{
			MethodName: "EditOffer",
			Handler:    _Offers_EditOffer_Handler,
		},
		{
			MethodName: "CancelOffer",
			Handler:    _Offers_CancelOffer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// PaymentAccountsClient is the client API for PaymentAccounts service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentAccountsClient interface {
	// Create a fiat payment account, providing details in a json form generated by rpc method GetPaymentAccountForm.
	CreatePaymentAccount(ctx context.Context, in *CreatePaymentAccountRequest, opts ...grpc.CallOption) (*CreatePaymentAccountReply, error)
	// Get list of all saved fiat payment accounts.
	GetPaymentAccounts(ctx context.Context, in *GetPaymentAccountsRequest, opts ...grpc.CallOption) (*GetPaymentAccountsReply, error)
	// Get list of all supported Bisq payment methods.
	GetPaymentMethods(ctx context.Context, in *GetPaymentMethodsRequest, opts ...grpc.CallOption) (*GetPaymentMethodsReply, error)
	// Get a json template file for a supported Bisq payment method.  Fill in the form and call rpc method CreatePaymentAccount.
	GetPaymentAccountForm(ctx context.Context, in *GetPaymentAccountFormRequest, opts ...grpc.CallOption) (*GetPaymentAccountFormReply, error)
	// Create a crypto currency (altcoin) payment account.
	CreateCryptoCurrencyPaymentAccount(ctx context.Context, in *CreateCryptoCurrencyPaymentAccountRequest, opts ...grpc.CallOption) (*CreateCryptoCurrencyPaymentAccountReply, error)
	// Get list of all supported Bisq crypto currency (altcoin) payment methods.
	GetCryptoCurrencyPaymentMethods(ctx context.Context, in *GetCryptoCurrencyPaymentMethodsRequest, opts ...grpc.CallOption) (*GetCryptoCurrencyPaymentMethodsReply, error)
}

type paymentAccountsClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentAccountsClient(cc grpc.ClientConnInterface) PaymentAccountsClient {
	return &paymentAccountsClient{cc}
}

func (c *paymentAccountsClient) CreatePaymentAccount(ctx context.Context, in *CreatePaymentAccountRequest, opts ...grpc.CallOption) (*CreatePaymentAccountReply, error) {
	out := new(CreatePaymentAccountReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/CreatePaymentAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetPaymentAccounts(ctx context.Context, in *GetPaymentAccountsRequest, opts ...grpc.CallOption) (*GetPaymentAccountsReply, error) {
	out := new(GetPaymentAccountsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetPaymentMethods(ctx context.Context, in *GetPaymentMethodsRequest, opts ...grpc.CallOption) (*GetPaymentMethodsReply, error) {
	out := new(GetPaymentMethodsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetPaymentMethods", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetPaymentAccountForm(ctx context.Context, in *GetPaymentAccountFormRequest, opts ...grpc.CallOption) (*GetPaymentAccountFormReply, error) {
	out := new(GetPaymentAccountFormReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccountForm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) CreateCryptoCurrencyPaymentAccount(ctx context.Context, in *CreateCryptoCurrencyPaymentAccountRequest, opts ...grpc.CallOption) (*CreateCryptoCurrencyPaymentAccountReply, error) {
	out := new(CreateCryptoCurrencyPaymentAccountReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/CreateCryptoCurrencyPaymentAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetCryptoCurrencyPaymentMethods(ctx context.Context, in *GetCryptoCurrencyPaymentMethodsRequest, opts ...grpc.CallOption) (*GetCryptoCurrencyPaymentMethodsReply, error) {
	out := new(GetCryptoCurrencyPaymentMethodsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetCryptoCurrencyPaymentMethods", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentAccountsServer is the server API for PaymentAccounts service.
// All implementations must embed UnimplementedPaymentAccountsServer
// for forward compatibility
type PaymentAccountsServer interface {
	// Create a fiat payment account, providing details in a json form generated by rpc method GetPaymentAccountForm.
	CreatePaymentAccount(context.Context, *CreatePaymentAccountRequest) (*CreatePaymentAccountReply, error)
	// Get list of all saved fiat payment accounts.
	GetPaymentAccounts(context.Context, *GetPaymentAccountsRequest) (*GetPaymentAccountsReply, error)
	// Get list of all supported Bisq payment methods.
	GetPaymentMethods(context.Context, *GetPaymentMethodsRequest) (*GetPaymentMethodsReply, error)
	// Get a json template file for a supported Bisq payment method.  Fill in the form and call rpc method CreatePaymentAccount.
	GetPaymentAccountForm(context.Context, *GetPaymentAccountFormRequest) (*GetPaymentAccountFormReply, error)
	// Create a crypto currency (altcoin) payment account.
	CreateCryptoCurrencyPaymentAccount(context.Context, *CreateCryptoCurrencyPaymentAccountRequest) (*CreateCryptoCurrencyPaymentAccountReply, error)
	// Get list of all supported Bisq crypto currency (altcoin) payment methods.
	GetCryptoCurrencyPaymentMethods(context.Context, *GetCryptoCurrencyPaymentMethodsRequest) (*GetCryptoCurrencyPaymentMethodsReply, error)
	mustEmbedUnimplementedPaymentAccountsServer()
}

// UnimplementedPaymentAccountsServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentAccountsServer struct {
}

func (UnimplementedPaymentAccountsServer) CreatePaymentAccount(context.Context, *CreatePaymentAccountRequest) (*CreatePaymentAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaymentAccount not implemented")
}
func (UnimplementedPaymentAccountsServer) GetPaymentAccounts(context.Context, *GetPaymentAccountsRequest) (*GetPaymentAccountsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentAccounts not implemented")
}
func (UnimplementedPaymentAccountsServer) GetPaymentMethods(context.Context, *GetPaymentMethodsRequest) (*GetPaymentMethodsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentMethods not implemented")
}
func (UnimplementedPaymentAccountsServer) GetPaymentAccountForm(context.Context, *GetPaymentAccountFormRequest) (*GetPaymentAccountFormReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentAccountForm not implemented")
}
func (UnimplementedPaymentAccountsServer) CreateCryptoCurrencyPaymentAccount(context.Context, *CreateCryptoCurrencyPaymentAccountRequest) (*CreateCryptoCurrencyPaymentAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCryptoCurrencyPaymentAccount not implemented")
}
func (UnimplementedPaymentAccountsServer) GetCryptoCurrencyPaymentMethods(context.Context, *GetCryptoCurrencyPaymentMethodsRequest) (*GetCryptoCurrencyPaymentMethodsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptoCurrencyPaymentMethods not implemented")
}
func (UnimplementedPaymentAccountsServer) mustEmbedUnimplementedPaymentAccountsServer() {}

// UnsafePaymentAccountsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentAccountsServer will
// result in compilation errors.
type UnsafePaymentAccountsServer interface {
	mustEmbedUnimplementedPaymentAccountsServer()
}

func RegisterPaymentAccountsServer(s grpc.ServiceRegistrar, srv PaymentAccountsServer) {
	s.RegisterService(&PaymentAccounts_ServiceDesc, srv)
}

func _PaymentAccounts_CreatePaymentAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaymentAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).CreatePaymentAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/CreatePaymentAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).CreatePaymentAccount(ctx, req.(*CreatePaymentAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetPaymentAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetPaymentAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetPaymentAccounts(ctx, req.(*GetPaymentAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentMethodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetPaymentMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetPaymentMethods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetPaymentMethods(ctx, req.(*GetPaymentMethodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetPaymentAccountForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentAccountFormRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetPaymentAccountForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccountForm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetPaymentAccountForm(ctx, req.(*GetPaymentAccountFormRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_CreateCryptoCurrencyPaymentAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCryptoCurrencyPaymentAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).CreateCryptoCurrencyPaymentAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/CreateCryptoCurrencyPaymentAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).CreateCryptoCurrencyPaymentAccount(ctx, req.(*CreateCryptoCurrencyPaymentAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetCryptoCurrencyPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCryptoCurrencyPaymentMethodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetCryptoCurrencyPaymentMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetCryptoCurrencyPaymentMethods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetCryptoCurrencyPaymentMethods(ctx, req.(*GetCryptoCurrencyPaymentMethodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentAccounts_ServiceDesc is the grpc.ServiceDesc for PaymentAccounts service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentAccounts_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.PaymentAccounts",
	HandlerType: (*PaymentAccountsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePaymentAccount",
			Handler:    _PaymentAccounts_CreatePaymentAccount_Handler,
		},
		{
			MethodName: "GetPaymentAccounts",
			Handler:    _PaymentAccounts_GetPaymentAccounts_Handler,
		},
		{
			MethodName: "GetPaymentMethods",
			Handler:    _PaymentAccounts_GetPaymentMethods_Handler,
		},
		{
			MethodName: "GetPaymentAccountForm",
			Handler:    _PaymentAccounts_GetPaymentAccountForm_Handler,
		},
		{
			MethodName: "CreateCryptoCurrencyPaymentAccount",
			Handler:    _PaymentAccounts_CreateCryptoCurrencyPaymentAccount_Handler,
		},
		{
			MethodName: "GetCryptoCurrencyPaymentMethods",
			Handler:    _PaymentAccounts_GetCryptoCurrencyPaymentMethods_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// PriceClient is the client API for Price service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PriceClient interface {
	// Get the current market price for a crypto currency.
	GetMarketPrice(ctx context.Context, in *MarketPriceRequest, opts ...grpc.CallOption) (*MarketPriceReply, error)
}

type priceClient struct {
	cc grpc.ClientConnInterface
}

func NewPriceClient(cc grpc.ClientConnInterface) PriceClient {
	return &priceClient{cc}
}

func (c *priceClient) GetMarketPrice(ctx context.Context, in *MarketPriceRequest, opts ...grpc.CallOption) (*MarketPriceReply, error) {
	out := new(MarketPriceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Price/GetMarketPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PriceServer is the server API for Price service.
// All implementations must embed UnimplementedPriceServer
// for forward compatibility
type PriceServer interface {
	// Get the current market price for a crypto currency.
	GetMarketPrice(context.Context, *MarketPriceRequest) (*MarketPriceReply, error)
	mustEmbedUnimplementedPriceServer()
}

// UnimplementedPriceServer must be embedded to have forward compatible implementations.
type UnimplementedPriceServer struct {
}

func (UnimplementedPriceServer) GetMarketPrice(context.Context, *MarketPriceRequest) (*MarketPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketPrice not implemented")
}
func (UnimplementedPriceServer) mustEmbedUnimplementedPriceServer() {}

// UnsafePriceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PriceServer will
// result in compilation errors.
type UnsafePriceServer interface {
	mustEmbedUnimplementedPriceServer()
}

func RegisterPriceServer(s grpc.ServiceRegistrar, srv PriceServer) {
	s.RegisterService(&Price_ServiceDesc, srv)
}

func _Price_GetMarketPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PriceServer).GetMarketPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Price/GetMarketPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PriceServer).GetMarketPrice(ctx, req.(*MarketPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Price_ServiceDesc is the grpc.ServiceDesc for Price service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Price_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Price",
	HandlerType: (*PriceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMarketPrice",
			Handler:    _Price_GetMarketPrice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// ShutdownServerClient is the client API for ShutdownServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShutdownServerClient interface {
	// Shut down a local Bisq daemon.
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error)
}

type shutdownServerClient struct {
	cc grpc.ClientConnInterface
}

func NewShutdownServerClient(cc grpc.ClientConnInterface) ShutdownServerClient {
	return &shutdownServerClient{cc}
}

func (c *shutdownServerClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error) {
	out := new(StopReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.ShutdownServer/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShutdownServerServer is the server API for ShutdownServer service.
// All implementations must embed UnimplementedShutdownServerServer
// for forward compatibility
type ShutdownServerServer interface {
	// Shut down a local Bisq daemon.
	Stop(context.Context, *StopRequest) (*StopReply, error)
	mustEmbedUnimplementedShutdownServerServer()
}

// UnimplementedShutdownServerServer must be embedded to have forward compatible implementations.
type UnimplementedShutdownServerServer struct {
}

func (UnimplementedShutdownServerServer) Stop(context.Context, *StopRequest) (*StopReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedShutdownServerServer) mustEmbedUnimplementedShutdownServerServer() {}

// UnsafeShutdownServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShutdownServerServer will
// result in compilation errors.
type UnsafeShutdownServerServer interface {
	mustEmbedUnimplementedShutdownServerServer()
}

func RegisterShutdownServerServer(s grpc.ServiceRegistrar, srv ShutdownServerServer) {
	s.RegisterService(&ShutdownServer_ServiceDesc, srv)
}

func _ShutdownServer_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShutdownServerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.ShutdownServer/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShutdownServerServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShutdownServer_ServiceDesc is the grpc.ServiceDesc for ShutdownServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShutdownServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.ShutdownServer",
	HandlerType: (*ShutdownServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Stop",
			Handler:    _ShutdownServer_Stop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// TradesClient is the client API for Trades service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradesClient interface {
	// Get a currently open trade.
	GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*GetTradeReply, error)
	// Get currently open, or historical trades (closed or failed).
	GetTrades(ctx context.Context, in *GetTradesRequest, opts ...grpc.CallOption) (*GetTradesReply, error)
	// Take an open offer.
	TakeOffer(ctx context.Context, in *TakeOfferRequest, opts ...grpc.CallOption) (*TakeOfferReply, error)
	// Send a 'payment started' message to a trading peer (the BTC seller).
	ConfirmPaymentStarted(ctx context.Context, in *ConfirmPaymentStartedRequest, opts ...grpc.CallOption) (*ConfirmPaymentStartedReply, error)
	// Send a 'payment received' message to a trading peer (the BTC buyer).
	ConfirmPaymentReceived(ctx context.Context, in *ConfirmPaymentReceivedRequest, opts ...grpc.CallOption) (*ConfirmPaymentReceivedReply, error)
	// Close a completed trade;  move it to trade history.
	CloseTrade(ctx context.Context, in *CloseTradeRequest, opts ...grpc.CallOption) (*CloseTradeReply, error)
	// Fail an open trade.
	FailTrade(ctx context.Context, in *FailTradeRequest, opts ...grpc.CallOption) (*FailTradeReply, error)
	// Unfail a failed trade.
	UnFailTrade(ctx context.Context, in *UnFailTradeRequest, opts ...grpc.CallOption) (*UnFailTradeReply, error)
	// Withdraw trade proceeds to an external bitcoin wallet address.
	WithdrawFunds(ctx context.Context, in *WithdrawFundsRequest, opts ...grpc.CallOption) (*WithdrawFundsReply, error)
}

type tradesClient struct {
	cc grpc.ClientConnInterface
}

func NewTradesClient(cc grpc.ClientConnInterface) TradesClient {
	return &tradesClient{cc}
}

func (c *tradesClient) GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*GetTradeReply, error) {
	out := new(GetTradeReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/GetTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) GetTrades(ctx context.Context, in *GetTradesRequest, opts ...grpc.CallOption) (*GetTradesReply, error) {
	out := new(GetTradesReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/GetTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) TakeOffer(ctx context.Context, in *TakeOfferRequest, opts ...grpc.CallOption) (*TakeOfferReply, error) {
	out := new(TakeOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/TakeOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) ConfirmPaymentStarted(ctx context.Context, in *ConfirmPaymentStartedRequest, opts ...grpc.CallOption) (*ConfirmPaymentStartedReply, error) {
	out := new(ConfirmPaymentStartedReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/ConfirmPaymentStarted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) ConfirmPaymentReceived(ctx context.Context, in *ConfirmPaymentReceivedRequest, opts ...grpc.CallOption) (*ConfirmPaymentReceivedReply, error) {
	out := new(ConfirmPaymentReceivedReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/ConfirmPaymentReceived", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) CloseTrade(ctx context.Context, in *CloseTradeRequest, opts ...grpc.CallOption) (*CloseTradeReply, error) {
	out := new(CloseTradeReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/CloseTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) FailTrade(ctx context.Context, in *FailTradeRequest, opts ...grpc.CallOption) (*FailTradeReply, error) {
	out := new(FailTradeReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/FailTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) UnFailTrade(ctx context.Context, in *UnFailTradeRequest, opts ...grpc.CallOption) (*UnFailTradeReply, error) {
	out := new(UnFailTradeReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/UnFailTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) WithdrawFunds(ctx context.Context, in *WithdrawFundsRequest, opts ...grpc.CallOption) (*WithdrawFundsReply, error) {
	out := new(WithdrawFundsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/WithdrawFunds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradesServer is the server API for Trades service.
// All implementations must embed UnimplementedTradesServer
// for forward compatibility
type TradesServer interface {
	// Get a currently open trade.
	GetTrade(context.Context, *GetTradeRequest) (*GetTradeReply, error)
	// Get currently open, or historical trades (closed or failed).
	GetTrades(context.Context, *GetTradesRequest) (*GetTradesReply, error)
	// Take an open offer.
	TakeOffer(context.Context, *TakeOfferRequest) (*TakeOfferReply, error)
	// Send a 'payment started' message to a trading peer (the BTC seller).
	ConfirmPaymentStarted(context.Context, *ConfirmPaymentStartedRequest) (*ConfirmPaymentStartedReply, error)
	// Send a 'payment received' message to a trading peer (the BTC buyer).
	ConfirmPaymentReceived(context.Context, *ConfirmPaymentReceivedRequest) (*ConfirmPaymentReceivedReply, error)
	// Close a completed trade;  move it to trade history.
	CloseTrade(context.Context, *CloseTradeRequest) (*CloseTradeReply, error)
	// Fail an open trade.
	FailTrade(context.Context, *FailTradeRequest) (*FailTradeReply, error)
	// Unfail a failed trade.
	UnFailTrade(context.Context, *UnFailTradeRequest) (*UnFailTradeReply, error)
	// Withdraw trade proceeds to an external bitcoin wallet address.
	WithdrawFunds(context.Context, *WithdrawFundsRequest) (*WithdrawFundsReply, error)
	mustEmbedUnimplementedTradesServer()
}

// UnimplementedTradesServer must be embedded to have forward compatible implementations.
type UnimplementedTradesServer struct {
}

func (UnimplementedTradesServer) GetTrade(context.Context, *GetTradeRequest) (*GetTradeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrade not implemented")
}
func (UnimplementedTradesServer) GetTrades(context.Context, *GetTradesRequest) (*GetTradesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrades not implemented")
}
func (UnimplementedTradesServer) TakeOffer(context.Context, *TakeOfferRequest) (*TakeOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeOffer not implemented")
}
func (UnimplementedTradesServer) ConfirmPaymentStarted(context.Context, *ConfirmPaymentStartedRequest) (*ConfirmPaymentStartedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmPaymentStarted not implemented")
}
func (UnimplementedTradesServer) ConfirmPaymentReceived(context.Context, *ConfirmPaymentReceivedRequest) (*ConfirmPaymentReceivedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmPaymentReceived not implemented")
}
func (UnimplementedTradesServer) CloseTrade(context.Context, *CloseTradeRequest) (*CloseTradeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseTrade not implemented")
}
func (UnimplementedTradesServer) FailTrade(context.Context, *FailTradeRequest) (*FailTradeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailTrade not implemented")
}
func (UnimplementedTradesServer) UnFailTrade(context.Context, *UnFailTradeRequest) (*UnFailTradeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnFailTrade not implemented")
}
func (UnimplementedTradesServer) WithdrawFunds(context.Context, *WithdrawFundsRequest) (*WithdrawFundsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFunds not implemented")
}
func (UnimplementedTradesServer) mustEmbedUnimplementedTradesServer() {}

// UnsafeTradesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradesServer will
// result in compilation errors.
type UnsafeTradesServer interface {
	mustEmbedUnimplementedTradesServer()
}

func RegisterTradesServer(s grpc.ServiceRegistrar, srv TradesServer) {
	s.RegisterService(&Trades_ServiceDesc, srv)
}

func _Trades_GetTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).GetTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/GetTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).GetTrade(ctx, req.(*GetTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_GetTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).GetTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/GetTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).GetTrades(ctx, req.(*GetTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_TakeOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).TakeOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/TakeOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).TakeOffer(ctx, req.(*TakeOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_ConfirmPaymentStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmPaymentStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).ConfirmPaymentStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/ConfirmPaymentStarted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).ConfirmPaymentStarted(ctx, req.(*ConfirmPaymentStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_ConfirmPaymentReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmPaymentReceivedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).ConfirmPaymentReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/ConfirmPaymentReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).ConfirmPaymentReceived(ctx, req.(*ConfirmPaymentReceivedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_CloseTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).CloseTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/CloseTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).CloseTrade(ctx, req.(*CloseTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_FailTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).FailTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/FailTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).FailTrade(ctx, req.(*FailTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_UnFailTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnFailTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).UnFailTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/UnFailTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).UnFailTrade(ctx, req.(*UnFailTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_WithdrawFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).WithdrawFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/WithdrawFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).WithdrawFunds(ctx, req.(*WithdrawFundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trades_ServiceDesc is the grpc.ServiceDesc for Trades service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trades_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Trades",
	HandlerType: (*TradesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrade",
			Handler:    _Trades_GetTrade_Handler,
		},
		{
			MethodName: "GetTrades",
			Handler:    _Trades_GetTrades_Handler,
		},
		{
			MethodName: "TakeOffer",
			Handler:    _Trades_TakeOffer_Handler,
		},
		{
			MethodName: "ConfirmPaymentStarted",
			Handler:    _Trades_ConfirmPaymentStarted_Handler,
		},
		{
			MethodName: "ConfirmPaymentReceived",
			Handler:    _Trades_ConfirmPaymentReceived_Handler,
		},
		{
			MethodName: "CloseTrade",
			Handler:    _Trades_CloseTrade_Handler,
		},
		{
			MethodName: "FailTrade",
			Handler:    _Trades_FailTrade_Handler,
		},
		{
			MethodName: "UnFailTrade",
			Handler:    _Trades_UnFailTrade_Handler,
		},
		{
			MethodName: "WithdrawFunds",
			Handler:    _Trades_WithdrawFunds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// WalletsClient is the client API for Wallets service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WalletsClient interface {
	// Get the Bisq wallet's current BSQ and BTC balances.
	GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesReply, error)
	// Get BTC balance for a wallet address.
	GetAddressBalance(ctx context.Context, in *GetAddressBalanceRequest, opts ...grpc.CallOption) (*GetAddressBalanceReply, error)
	// Get an unused BSQ wallet address.
	GetUnusedBsqAddress(ctx context.Context, in *GetUnusedBsqAddressRequest, opts ...grpc.CallOption) (*GetUnusedBsqAddressReply, error)
	// Send an amount of BSQ to an external address.
	SendBsq(ctx context.Context, in *SendBsqRequest, opts ...grpc.CallOption) (*SendBsqReply, error)
	// Send an amount of BTC to an external address.
	SendBtc(ctx context.Context, in *SendBtcRequest, opts ...grpc.CallOption) (*SendBtcReply, error)
	// Verify a specific amount of BSQ was received by a BSQ wallet address.
	// This is a problematic way of verifying BSQ payment has been received for a v1 trade protocol BSQ-BTC trade,
	// which has been solved by the introduction of BSQ swap trades, which use a different, unused BSQ address for each trade.
	VerifyBsqSentToAddress(ctx context.Context, in *VerifyBsqSentToAddressRequest, opts ...grpc.CallOption) (*VerifyBsqSentToAddressReply, error)
	// Get the Bisq network's most recently available bitcoin miner transaction fee rate, or custom fee rate if set.
	GetTxFeeRate(ctx context.Context, in *GetTxFeeRateRequest, opts ...grpc.CallOption) (*GetTxFeeRateReply, error)
	// Set the Bisq daemon's custom bitcoin miner transaction fee rate, in sats/byte..
	SetTxFeeRatePreference(ctx context.Context, in *SetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*SetTxFeeRatePreferenceReply, error)
	// Remove the custom bitcoin miner transaction fee rate;  revert to the Bisq network's bitcoin miner transaction fee rate.
	UnsetTxFeeRatePreference(ctx context.Context, in *UnsetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*UnsetTxFeeRatePreferenceReply, error)
	// Get a bitcoin transaction summary.
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionReply, error)
	// Get all bitcoin receiving addresses in the Bisq BTC wallet.
	GetFundingAddresses(ctx context.Context, in *GetFundingAddressesRequest, opts ...grpc.CallOption) (*GetFundingAddressesReply, error)
	// Set the Bisq wallet's encryption password.
	SetWalletPassword(ctx context.Context, in *SetWalletPasswordRequest, opts ...grpc.CallOption) (*SetWalletPasswordReply, error)
	// Remove the encryption password from the Bisq wallet.
	RemoveWalletPassword(ctx context.Context, in *RemoveWalletPasswordRequest, opts ...grpc.CallOption) (*RemoveWalletPasswordReply, error)
	// Lock an encrypted Bisq wallet before the UnlockWallet rpc method's timeout period has expired.
	LockWallet(ctx context.Context, in *LockWalletRequest, opts ...grpc.CallOption) (*LockWalletReply, error)
	// Unlock a Bisq encrypted wallet before calling wallet sensitive rpc methods: CreateOffer, TakeOffer, GetBalances,
	// etc., for a timeout period in seconds.  An unlocked wallet will automatically lock itself after the timeout
	// period has expired, or a LockWallet request has been made, whichever is first.  An unlocked wallet's timeout
	// setting can be overridden by subsequent UnlockWallet calls.
	UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletReply, error)
}

type walletsClient struct {
	cc grpc.ClientConnInterface
}

func NewWalletsClient(cc grpc.ClientConnInterface) WalletsClient {
	return &walletsClient{cc}
}

func (c *walletsClient) GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesReply, error) {
	out := new(GetBalancesReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetAddressBalance(ctx context.Context, in *GetAddressBalanceRequest, opts ...grpc.CallOption) (*GetAddressBalanceReply, error) {
	out := new(GetAddressBalanceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetAddressBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetUnusedBsqAddress(ctx context.Context, in *GetUnusedBsqAddressRequest, opts ...grpc.CallOption) (*GetUnusedBsqAddressReply, error) {
	out := new(GetUnusedBsqAddressReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetUnusedBsqAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SendBsq(ctx context.Context, in *SendBsqRequest, opts ...grpc.CallOption) (*SendBsqReply, error) {
	out := new(SendBsqReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SendBsq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SendBtc(ctx context.Context, in *SendBtcRequest, opts ...grpc.CallOption) (*SendBtcReply, error) {
	out := new(SendBtcReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SendBtc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) VerifyBsqSentToAddress(ctx context.Context, in *VerifyBsqSentToAddressRequest, opts ...grpc.CallOption) (*VerifyBsqSentToAddressReply, error) {
	out := new(VerifyBsqSentToAddressReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/VerifyBsqSentToAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetTxFeeRate(ctx context.Context, in *GetTxFeeRateRequest, opts ...grpc.CallOption) (*GetTxFeeRateReply, error) {
	out := new(GetTxFeeRateReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetTxFeeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SetTxFeeRatePreference(ctx context.Context, in *SetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*SetTxFeeRatePreferenceReply, error) {
	out := new(SetTxFeeRatePreferenceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SetTxFeeRatePreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) UnsetTxFeeRatePreference(ctx context.Context, in *UnsetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*UnsetTxFeeRatePreferenceReply, error) {
	out := new(UnsetTxFeeRatePreferenceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/UnsetTxFeeRatePreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionReply, error) {
	out := new(GetTransactionReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetFundingAddresses(ctx context.Context, in *GetFundingAddressesRequest, opts ...grpc.CallOption) (*GetFundingAddressesReply, error) {
	out := new(GetFundingAddressesReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetFundingAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SetWalletPassword(ctx context.Context, in *SetWalletPasswordRequest, opts ...grpc.CallOption) (*SetWalletPasswordReply, error) {
	out := new(SetWalletPasswordReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SetWalletPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) RemoveWalletPassword(ctx context.Context, in *RemoveWalletPasswordRequest, opts ...grpc.CallOption) (*RemoveWalletPasswordReply, error) {
	out := new(RemoveWalletPasswordReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/RemoveWalletPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) LockWallet(ctx context.Context, in *LockWalletRequest, opts ...grpc.CallOption) (*LockWalletReply, error) {
	out := new(LockWalletReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/LockWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletReply, error) {
	out := new(UnlockWalletReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/UnlockWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletsServer is the server API for Wallets service.
// All implementations must embed UnimplementedWalletsServer
// for forward compatibility
type WalletsServer interface {
	// Get the Bisq wallet's current BSQ and BTC balances.
	GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesReply, error)
	// Get BTC balance for a wallet address.
	GetAddressBalance(context.Context, *GetAddressBalanceRequest) (*GetAddressBalanceReply, error)
	// Get an unused BSQ wallet address.
	GetUnusedBsqAddress(context.Context, *GetUnusedBsqAddressRequest) (*GetUnusedBsqAddressReply, error)
	// Send an amount of BSQ to an external address.
	SendBsq(context.Context, *SendBsqRequest) (*SendBsqReply, error)
	// Send an amount of BTC to an external address.
	SendBtc(context.Context, *SendBtcRequest) (*SendBtcReply, error)
	// Verify a specific amount of BSQ was received by a BSQ wallet address.
	// This is a problematic way of verifying BSQ payment has been received for a v1 trade protocol BSQ-BTC trade,
	// which has been solved by the introduction of BSQ swap trades, which use a different, unused BSQ address for each trade.
	VerifyBsqSentToAddress(context.Context, *VerifyBsqSentToAddressRequest) (*VerifyBsqSentToAddressReply, error)
	// Get the Bisq network's most recently available bitcoin miner transaction fee rate, or custom fee rate if set.
	GetTxFeeRate(context.Context, *GetTxFeeRateRequest) (*GetTxFeeRateReply, error)
	// Set the Bisq daemon's custom bitcoin miner transaction fee rate, in sats/byte..
	SetTxFeeRatePreference(context.Context, *SetTxFeeRatePreferenceRequest) (*SetTxFeeRatePreferenceReply, error)
	// Remove the custom bitcoin miner transaction fee rate;  revert to the Bisq network's bitcoin miner transaction fee rate.
	UnsetTxFeeRatePreference(context.Context, *UnsetTxFeeRatePreferenceRequest) (*UnsetTxFeeRatePreferenceReply, error)
	// Get a bitcoin transaction summary.
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionReply, error)
	// Get all bitcoin receiving addresses in the Bisq BTC wallet.
	GetFundingAddresses(context.Context, *GetFundingAddressesRequest) (*GetFundingAddressesReply, error)
	// Set the Bisq wallet's encryption password.
	SetWalletPassword(context.Context, *SetWalletPasswordRequest) (*SetWalletPasswordReply, error)
	// Remove the encryption password from the Bisq wallet.
	RemoveWalletPassword(context.Context, *RemoveWalletPasswordRequest) (*RemoveWalletPasswordReply, error)
	// Lock an encrypted Bisq wallet before the UnlockWallet rpc method's timeout period has expired.
	LockWallet(context.Context, *LockWalletRequest) (*LockWalletReply, error)
	// Unlock a Bisq encrypted wallet before calling wallet sensitive rpc methods: CreateOffer, TakeOffer, GetBalances,
	// etc., for a timeout period in seconds.  An unlocked wallet will automatically lock itself after the timeout
	// period has expired, or a LockWallet request has been made, whichever is first.  An unlocked wallet's timeout
	// setting can be overridden by subsequent UnlockWallet calls.
	UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletReply, error)
	mustEmbedUnimplementedWalletsServer()
}

// UnimplementedWalletsServer must be embedded to have forward compatible implementations.
type UnimplementedWalletsServer struct {
}

func (UnimplementedWalletsServer) GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalances not implemented")
}
func (UnimplementedWalletsServer) GetAddressBalance(context.Context, *GetAddressBalanceRequest) (*GetAddressBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressBalance not implemented")
}
func (UnimplementedWalletsServer) GetUnusedBsqAddress(context.Context, *GetUnusedBsqAddressRequest) (*GetUnusedBsqAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnusedBsqAddress not implemented")
}
func (UnimplementedWalletsServer) SendBsq(context.Context, *SendBsqRequest) (*SendBsqReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBsq not implemented")
}
func (UnimplementedWalletsServer) SendBtc(context.Context, *SendBtcRequest) (*SendBtcReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBtc not implemented")
}
func (UnimplementedWalletsServer) VerifyBsqSentToAddress(context.Context, *VerifyBsqSentToAddressRequest) (*VerifyBsqSentToAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyBsqSentToAddress not implemented")
}
func (UnimplementedWalletsServer) GetTxFeeRate(context.Context, *GetTxFeeRateRequest) (*GetTxFeeRateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxFeeRate not implemented")
}
func (UnimplementedWalletsServer) SetTxFeeRatePreference(context.Context, *SetTxFeeRatePreferenceRequest) (*SetTxFeeRatePreferenceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTxFeeRatePreference not implemented")
}
func (UnimplementedWalletsServer) UnsetTxFeeRatePreference(context.Context, *UnsetTxFeeRatePreferenceRequest) (*UnsetTxFeeRatePreferenceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsetTxFeeRatePreference not implemented")
}
func (UnimplementedWalletsServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedWalletsServer) GetFundingAddresses(context.Context, *GetFundingAddressesRequest) (*GetFundingAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFundingAddresses not implemented")
}
func (UnimplementedWalletsServer) SetWalletPassword(context.Context, *SetWalletPasswordRequest) (*SetWalletPasswordReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWalletPassword not implemented")
}
func (UnimplementedWalletsServer) RemoveWalletPassword(context.Context, *RemoveWalletPasswordRequest) (*RemoveWalletPasswordReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveWalletPassword not implemented")
}
func (UnimplementedWalletsServer) LockWallet(context.Context, *LockWalletRequest) (*LockWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockWallet not implemented")
}
func (UnimplementedWalletsServer) UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockWallet not implemented")
}
func (UnimplementedWalletsServer) mustEmbedUnimplementedWalletsServer() {}

// UnsafeWalletsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WalletsServer will
// result in compilation errors.
type UnsafeWalletsServer interface {
	mustEmbedUnimplementedWalletsServer()
}

func RegisterWalletsServer(s grpc.ServiceRegistrar, srv WalletsServer) {
	s.RegisterService(&Wallets_ServiceDesc, srv)
}

func _Wallets_GetBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetBalances(ctx, req.(*GetBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetAddressBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetAddressBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetAddressBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetAddressBalance(ctx, req.(*GetAddressBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetUnusedBsqAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnusedBsqAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetUnusedBsqAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetUnusedBsqAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetUnusedBsqAddress(ctx, req.(*GetUnusedBsqAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SendBsq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBsqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SendBsq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SendBsq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SendBsq(ctx, req.(*SendBsqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SendBtc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBtcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SendBtc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SendBtc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SendBtc(ctx, req.(*SendBtcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_VerifyBsqSentToAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyBsqSentToAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).VerifyBsqSentToAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/VerifyBsqSentToAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).VerifyBsqSentToAddress(ctx, req.(*VerifyBsqSentToAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetTxFeeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxFeeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetTxFeeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetTxFeeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetTxFeeRate(ctx, req.(*GetTxFeeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SetTxFeeRatePreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTxFeeRatePreferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SetTxFeeRatePreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SetTxFeeRatePreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SetTxFeeRatePreference(ctx, req.(*SetTxFeeRatePreferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_UnsetTxFeeRatePreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsetTxFeeRatePreferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).UnsetTxFeeRatePreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/UnsetTxFeeRatePreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).UnsetTxFeeRatePreference(ctx, req.(*UnsetTxFeeRatePreferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetFundingAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFundingAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetFundingAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetFundingAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetFundingAddresses(ctx, req.(*GetFundingAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SetWalletPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetWalletPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SetWalletPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SetWalletPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SetWalletPassword(ctx, req.(*SetWalletPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_RemoveWalletPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveWalletPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).RemoveWalletPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/RemoveWalletPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).RemoveWalletPassword(ctx, req.(*RemoveWalletPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_LockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).LockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/LockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).LockWallet(ctx, req.(*LockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_UnlockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).UnlockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/UnlockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).UnlockWallet(ctx, req.(*UnlockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Wallets_ServiceDesc is the grpc.ServiceDesc for Wallets service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Wallets_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Wallets",
	HandlerType: (*WalletsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBalances",
			Handler:    _Wallets_GetBalances_Handler,
		},
		{
			MethodName: "GetAddressBalance",
			Handler:    _Wallets_GetAddressBalance_Handler,
		},
		{
			MethodName: "GetUnusedBsqAddress",
			Handler:    _Wallets_GetUnusedBsqAddress_Handler,
		},
		{
			MethodName: "SendBsq",
			Handler:    _Wallets_SendBsq_Handler,
		},
		{
			MethodName: "SendBtc",
			Handler:    _Wallets_SendBtc_Handler,
		},
		{
			MethodName: "VerifyBsqSentToAddress",
			Handler:    _Wallets_VerifyBsqSentToAddress_Handler,
		},
		{
			MethodName: "GetTxFeeRate",
			Handler:    _Wallets_GetTxFeeRate_Handler,
		},
		{
			MethodName: "SetTxFeeRatePreference",
			Handler:    _Wallets_SetTxFeeRatePreference_Handler,
		},
		{
			MethodName: "UnsetTxFeeRatePreference",
			Handler:    _Wallets_UnsetTxFeeRatePreference_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _Wallets_GetTransaction_Handler,
		},
		{
			MethodName: "GetFundingAddresses",
			Handler:    _Wallets_GetFundingAddresses_Handler,
		},
		{
			MethodName: "SetWalletPassword",
			Handler:    _Wallets_SetWalletPassword_Handler,
		},
		{
			MethodName: "RemoveWalletPassword",
			Handler:    _Wallets_RemoveWalletPassword_Handler,
		},
		{
			MethodName: "LockWallet",
			Handler:    _Wallets_LockWallet_Handler,
		},
		{
			MethodName: "UnlockWallet",
			Handler:    _Wallets_UnlockWallet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// GetVersionClient is the client API for GetVersion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GetVersionClient interface {
	// Get the current Bisq version number.
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionReply, error)
}

type getVersionClient struct {
	cc grpc.ClientConnInterface
}

func NewGetVersionClient(cc grpc.ClientConnInterface) GetVersionClient {
	return &getVersionClient{cc}
}

func (c *getVersionClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionReply, error) {
	out := new(GetVersionReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.GetVersion/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetVersionServer is the server API for GetVersion service.
// All implementations must embed UnimplementedGetVersionServer
// for forward compatibility
type GetVersionServer interface {
	// Get the current Bisq version number.
	GetVersion(context.Context, *GetVersionRequest) (*GetVersionReply, error)
	mustEmbedUnimplementedGetVersionServer()
}

// UnimplementedGetVersionServer must be embedded to have forward compatible implementations.
type UnimplementedGetVersionServer struct {
}

func (UnimplementedGetVersionServer) GetVersion(context.Context, *GetVersionRequest) (*GetVersionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedGetVersionServer) mustEmbedUnimplementedGetVersionServer() {}

// UnsafeGetVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GetVersionServer will
// result in compilation errors.
type UnsafeGetVersionServer interface {
	mustEmbedUnimplementedGetVersionServer()
}

func RegisterGetVersionServer(s grpc.ServiceRegistrar, srv GetVersionServer) {
	s.RegisterService(&GetVersion_ServiceDesc, srv)
}

func _GetVersion_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetVersionServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.GetVersion/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetVersionServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GetVersion_ServiceDesc is the grpc.ServiceDesc for GetVersion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GetVersion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.GetVersion",
	HandlerType: (*GetVersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _GetVersion_GetVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}
