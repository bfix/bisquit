// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package bisquit

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DisputeAgentsClient is the client API for DisputeAgents service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DisputeAgentsClient interface {
	RegisterDisputeAgent(ctx context.Context, in *RegisterDisputeAgentRequest, opts ...grpc.CallOption) (*RegisterDisputeAgentReply, error)
}

type disputeAgentsClient struct {
	cc grpc.ClientConnInterface
}

func NewDisputeAgentsClient(cc grpc.ClientConnInterface) DisputeAgentsClient {
	return &disputeAgentsClient{cc}
}

func (c *disputeAgentsClient) RegisterDisputeAgent(ctx context.Context, in *RegisterDisputeAgentRequest, opts ...grpc.CallOption) (*RegisterDisputeAgentReply, error) {
	out := new(RegisterDisputeAgentReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.DisputeAgents/RegisterDisputeAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DisputeAgentsServer is the server API for DisputeAgents service.
// All implementations must embed UnimplementedDisputeAgentsServer
// for forward compatibility
type DisputeAgentsServer interface {
	RegisterDisputeAgent(context.Context, *RegisterDisputeAgentRequest) (*RegisterDisputeAgentReply, error)
	mustEmbedUnimplementedDisputeAgentsServer()
}

// UnimplementedDisputeAgentsServer must be embedded to have forward compatible implementations.
type UnimplementedDisputeAgentsServer struct {
}

func (UnimplementedDisputeAgentsServer) RegisterDisputeAgent(context.Context, *RegisterDisputeAgentRequest) (*RegisterDisputeAgentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDisputeAgent not implemented")
}
func (UnimplementedDisputeAgentsServer) mustEmbedUnimplementedDisputeAgentsServer() {}

// UnsafeDisputeAgentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DisputeAgentsServer will
// result in compilation errors.
type UnsafeDisputeAgentsServer interface {
	mustEmbedUnimplementedDisputeAgentsServer()
}

func RegisterDisputeAgentsServer(s grpc.ServiceRegistrar, srv DisputeAgentsServer) {
	s.RegisterService(&DisputeAgents_ServiceDesc, srv)
}

func _DisputeAgents_RegisterDisputeAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDisputeAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisputeAgentsServer).RegisterDisputeAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.DisputeAgents/RegisterDisputeAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisputeAgentsServer).RegisterDisputeAgent(ctx, req.(*RegisterDisputeAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DisputeAgents_ServiceDesc is the grpc.ServiceDesc for DisputeAgents service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DisputeAgents_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.DisputeAgents",
	HandlerType: (*DisputeAgentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDisputeAgent",
			Handler:    _DisputeAgents_RegisterDisputeAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// HelpClient is the client API for Help service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HelpClient interface {
	GetMethodHelp(ctx context.Context, in *GetMethodHelpRequest, opts ...grpc.CallOption) (*GetMethodHelpReply, error)
}

type helpClient struct {
	cc grpc.ClientConnInterface
}

func NewHelpClient(cc grpc.ClientConnInterface) HelpClient {
	return &helpClient{cc}
}

func (c *helpClient) GetMethodHelp(ctx context.Context, in *GetMethodHelpRequest, opts ...grpc.CallOption) (*GetMethodHelpReply, error) {
	out := new(GetMethodHelpReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Help/GetMethodHelp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HelpServer is the server API for Help service.
// All implementations must embed UnimplementedHelpServer
// for forward compatibility
type HelpServer interface {
	GetMethodHelp(context.Context, *GetMethodHelpRequest) (*GetMethodHelpReply, error)
	mustEmbedUnimplementedHelpServer()
}

// UnimplementedHelpServer must be embedded to have forward compatible implementations.
type UnimplementedHelpServer struct {
}

func (UnimplementedHelpServer) GetMethodHelp(context.Context, *GetMethodHelpRequest) (*GetMethodHelpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMethodHelp not implemented")
}
func (UnimplementedHelpServer) mustEmbedUnimplementedHelpServer() {}

// UnsafeHelpServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HelpServer will
// result in compilation errors.
type UnsafeHelpServer interface {
	mustEmbedUnimplementedHelpServer()
}

func RegisterHelpServer(s grpc.ServiceRegistrar, srv HelpServer) {
	s.RegisterService(&Help_ServiceDesc, srv)
}

func _Help_GetMethodHelp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMethodHelpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelpServer).GetMethodHelp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Help/GetMethodHelp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelpServer).GetMethodHelp(ctx, req.(*GetMethodHelpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Help_ServiceDesc is the grpc.ServiceDesc for Help service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Help_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Help",
	HandlerType: (*HelpServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMethodHelp",
			Handler:    _Help_GetMethodHelp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// OffersClient is the client API for Offers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OffersClient interface {
	GetOffer(ctx context.Context, in *GetOfferRequest, opts ...grpc.CallOption) (*GetOfferReply, error)
	GetMyOffer(ctx context.Context, in *GetMyOfferRequest, opts ...grpc.CallOption) (*GetMyOfferReply, error)
	GetOffers(ctx context.Context, in *GetOffersRequest, opts ...grpc.CallOption) (*GetOffersReply, error)
	GetMyOffers(ctx context.Context, in *GetMyOffersRequest, opts ...grpc.CallOption) (*GetMyOffersReply, error)
	CreateOffer(ctx context.Context, in *CreateOfferRequest, opts ...grpc.CallOption) (*CreateOfferReply, error)
	CancelOffer(ctx context.Context, in *CancelOfferRequest, opts ...grpc.CallOption) (*CancelOfferReply, error)
}

type offersClient struct {
	cc grpc.ClientConnInterface
}

func NewOffersClient(cc grpc.ClientConnInterface) OffersClient {
	return &offersClient{cc}
}

func (c *offersClient) GetOffer(ctx context.Context, in *GetOfferRequest, opts ...grpc.CallOption) (*GetOfferReply, error) {
	out := new(GetOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetMyOffer(ctx context.Context, in *GetMyOfferRequest, opts ...grpc.CallOption) (*GetMyOfferReply, error) {
	out := new(GetMyOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetMyOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetOffers(ctx context.Context, in *GetOffersRequest, opts ...grpc.CallOption) (*GetOffersReply, error) {
	out := new(GetOffersReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) GetMyOffers(ctx context.Context, in *GetMyOffersRequest, opts ...grpc.CallOption) (*GetMyOffersReply, error) {
	out := new(GetMyOffersReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/GetMyOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) CreateOffer(ctx context.Context, in *CreateOfferRequest, opts ...grpc.CallOption) (*CreateOfferReply, error) {
	out := new(CreateOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/CreateOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *offersClient) CancelOffer(ctx context.Context, in *CancelOfferRequest, opts ...grpc.CallOption) (*CancelOfferReply, error) {
	out := new(CancelOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Offers/CancelOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OffersServer is the server API for Offers service.
// All implementations must embed UnimplementedOffersServer
// for forward compatibility
type OffersServer interface {
	GetOffer(context.Context, *GetOfferRequest) (*GetOfferReply, error)
	GetMyOffer(context.Context, *GetMyOfferRequest) (*GetMyOfferReply, error)
	GetOffers(context.Context, *GetOffersRequest) (*GetOffersReply, error)
	GetMyOffers(context.Context, *GetMyOffersRequest) (*GetMyOffersReply, error)
	CreateOffer(context.Context, *CreateOfferRequest) (*CreateOfferReply, error)
	CancelOffer(context.Context, *CancelOfferRequest) (*CancelOfferReply, error)
	mustEmbedUnimplementedOffersServer()
}

// UnimplementedOffersServer must be embedded to have forward compatible implementations.
type UnimplementedOffersServer struct {
}

func (UnimplementedOffersServer) GetOffer(context.Context, *GetOfferRequest) (*GetOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOffer not implemented")
}
func (UnimplementedOffersServer) GetMyOffer(context.Context, *GetMyOfferRequest) (*GetMyOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyOffer not implemented")
}
func (UnimplementedOffersServer) GetOffers(context.Context, *GetOffersRequest) (*GetOffersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOffers not implemented")
}
func (UnimplementedOffersServer) GetMyOffers(context.Context, *GetMyOffersRequest) (*GetMyOffersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyOffers not implemented")
}
func (UnimplementedOffersServer) CreateOffer(context.Context, *CreateOfferRequest) (*CreateOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOffer not implemented")
}
func (UnimplementedOffersServer) CancelOffer(context.Context, *CancelOfferRequest) (*CancelOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOffer not implemented")
}
func (UnimplementedOffersServer) mustEmbedUnimplementedOffersServer() {}

// UnsafeOffersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OffersServer will
// result in compilation errors.
type UnsafeOffersServer interface {
	mustEmbedUnimplementedOffersServer()
}

func RegisterOffersServer(s grpc.ServiceRegistrar, srv OffersServer) {
	s.RegisterService(&Offers_ServiceDesc, srv)
}

func _Offers_GetOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetOffer(ctx, req.(*GetOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetMyOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetMyOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetMyOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetMyOffer(ctx, req.(*GetMyOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetOffers(ctx, req.(*GetOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_GetMyOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyOffersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).GetMyOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/GetMyOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).GetMyOffers(ctx, req.(*GetMyOffersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_CreateOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).CreateOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/CreateOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).CreateOffer(ctx, req.(*CreateOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Offers_CancelOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OffersServer).CancelOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Offers/CancelOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OffersServer).CancelOffer(ctx, req.(*CancelOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Offers_ServiceDesc is the grpc.ServiceDesc for Offers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Offers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Offers",
	HandlerType: (*OffersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOffer",
			Handler:    _Offers_GetOffer_Handler,
		},
		{
			MethodName: "GetMyOffer",
			Handler:    _Offers_GetMyOffer_Handler,
		},
		{
			MethodName: "GetOffers",
			Handler:    _Offers_GetOffers_Handler,
		},
		{
			MethodName: "GetMyOffers",
			Handler:    _Offers_GetMyOffers_Handler,
		},
		{
			MethodName: "CreateOffer",
			Handler:    _Offers_CreateOffer_Handler,
		},
		{
			MethodName: "CancelOffer",
			Handler:    _Offers_CancelOffer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// PaymentAccountsClient is the client API for PaymentAccounts service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentAccountsClient interface {
	CreatePaymentAccount(ctx context.Context, in *CreatePaymentAccountRequest, opts ...grpc.CallOption) (*CreatePaymentAccountReply, error)
	GetPaymentAccounts(ctx context.Context, in *GetPaymentAccountsRequest, opts ...grpc.CallOption) (*GetPaymentAccountsReply, error)
	GetPaymentMethods(ctx context.Context, in *GetPaymentMethodsRequest, opts ...grpc.CallOption) (*GetPaymentMethodsReply, error)
	GetPaymentAccountForm(ctx context.Context, in *GetPaymentAccountFormRequest, opts ...grpc.CallOption) (*GetPaymentAccountFormReply, error)
}

type paymentAccountsClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentAccountsClient(cc grpc.ClientConnInterface) PaymentAccountsClient {
	return &paymentAccountsClient{cc}
}

func (c *paymentAccountsClient) CreatePaymentAccount(ctx context.Context, in *CreatePaymentAccountRequest, opts ...grpc.CallOption) (*CreatePaymentAccountReply, error) {
	out := new(CreatePaymentAccountReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/CreatePaymentAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetPaymentAccounts(ctx context.Context, in *GetPaymentAccountsRequest, opts ...grpc.CallOption) (*GetPaymentAccountsReply, error) {
	out := new(GetPaymentAccountsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetPaymentMethods(ctx context.Context, in *GetPaymentMethodsRequest, opts ...grpc.CallOption) (*GetPaymentMethodsReply, error) {
	out := new(GetPaymentMethodsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetPaymentMethods", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentAccountsClient) GetPaymentAccountForm(ctx context.Context, in *GetPaymentAccountFormRequest, opts ...grpc.CallOption) (*GetPaymentAccountFormReply, error) {
	out := new(GetPaymentAccountFormReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccountForm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentAccountsServer is the server API for PaymentAccounts service.
// All implementations must embed UnimplementedPaymentAccountsServer
// for forward compatibility
type PaymentAccountsServer interface {
	CreatePaymentAccount(context.Context, *CreatePaymentAccountRequest) (*CreatePaymentAccountReply, error)
	GetPaymentAccounts(context.Context, *GetPaymentAccountsRequest) (*GetPaymentAccountsReply, error)
	GetPaymentMethods(context.Context, *GetPaymentMethodsRequest) (*GetPaymentMethodsReply, error)
	GetPaymentAccountForm(context.Context, *GetPaymentAccountFormRequest) (*GetPaymentAccountFormReply, error)
	mustEmbedUnimplementedPaymentAccountsServer()
}

// UnimplementedPaymentAccountsServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentAccountsServer struct {
}

func (UnimplementedPaymentAccountsServer) CreatePaymentAccount(context.Context, *CreatePaymentAccountRequest) (*CreatePaymentAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaymentAccount not implemented")
}
func (UnimplementedPaymentAccountsServer) GetPaymentAccounts(context.Context, *GetPaymentAccountsRequest) (*GetPaymentAccountsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentAccounts not implemented")
}
func (UnimplementedPaymentAccountsServer) GetPaymentMethods(context.Context, *GetPaymentMethodsRequest) (*GetPaymentMethodsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentMethods not implemented")
}
func (UnimplementedPaymentAccountsServer) GetPaymentAccountForm(context.Context, *GetPaymentAccountFormRequest) (*GetPaymentAccountFormReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentAccountForm not implemented")
}
func (UnimplementedPaymentAccountsServer) mustEmbedUnimplementedPaymentAccountsServer() {}

// UnsafePaymentAccountsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentAccountsServer will
// result in compilation errors.
type UnsafePaymentAccountsServer interface {
	mustEmbedUnimplementedPaymentAccountsServer()
}

func RegisterPaymentAccountsServer(s grpc.ServiceRegistrar, srv PaymentAccountsServer) {
	s.RegisterService(&PaymentAccounts_ServiceDesc, srv)
}

func _PaymentAccounts_CreatePaymentAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaymentAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).CreatePaymentAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/CreatePaymentAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).CreatePaymentAccount(ctx, req.(*CreatePaymentAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetPaymentAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetPaymentAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetPaymentAccounts(ctx, req.(*GetPaymentAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentMethodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetPaymentMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetPaymentMethods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetPaymentMethods(ctx, req.(*GetPaymentMethodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentAccounts_GetPaymentAccountForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentAccountFormRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentAccountsServer).GetPaymentAccountForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.PaymentAccounts/GetPaymentAccountForm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentAccountsServer).GetPaymentAccountForm(ctx, req.(*GetPaymentAccountFormRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentAccounts_ServiceDesc is the grpc.ServiceDesc for PaymentAccounts service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentAccounts_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.PaymentAccounts",
	HandlerType: (*PaymentAccountsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePaymentAccount",
			Handler:    _PaymentAccounts_CreatePaymentAccount_Handler,
		},
		{
			MethodName: "GetPaymentAccounts",
			Handler:    _PaymentAccounts_GetPaymentAccounts_Handler,
		},
		{
			MethodName: "GetPaymentMethods",
			Handler:    _PaymentAccounts_GetPaymentMethods_Handler,
		},
		{
			MethodName: "GetPaymentAccountForm",
			Handler:    _PaymentAccounts_GetPaymentAccountForm_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// PriceClient is the client API for Price service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PriceClient interface {
	GetMarketPrice(ctx context.Context, in *MarketPriceRequest, opts ...grpc.CallOption) (*MarketPriceReply, error)
}

type priceClient struct {
	cc grpc.ClientConnInterface
}

func NewPriceClient(cc grpc.ClientConnInterface) PriceClient {
	return &priceClient{cc}
}

func (c *priceClient) GetMarketPrice(ctx context.Context, in *MarketPriceRequest, opts ...grpc.CallOption) (*MarketPriceReply, error) {
	out := new(MarketPriceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Price/GetMarketPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PriceServer is the server API for Price service.
// All implementations must embed UnimplementedPriceServer
// for forward compatibility
type PriceServer interface {
	GetMarketPrice(context.Context, *MarketPriceRequest) (*MarketPriceReply, error)
	mustEmbedUnimplementedPriceServer()
}

// UnimplementedPriceServer must be embedded to have forward compatible implementations.
type UnimplementedPriceServer struct {
}

func (UnimplementedPriceServer) GetMarketPrice(context.Context, *MarketPriceRequest) (*MarketPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarketPrice not implemented")
}
func (UnimplementedPriceServer) mustEmbedUnimplementedPriceServer() {}

// UnsafePriceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PriceServer will
// result in compilation errors.
type UnsafePriceServer interface {
	mustEmbedUnimplementedPriceServer()
}

func RegisterPriceServer(s grpc.ServiceRegistrar, srv PriceServer) {
	s.RegisterService(&Price_ServiceDesc, srv)
}

func _Price_GetMarketPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PriceServer).GetMarketPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Price/GetMarketPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PriceServer).GetMarketPrice(ctx, req.(*MarketPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Price_ServiceDesc is the grpc.ServiceDesc for Price service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Price_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Price",
	HandlerType: (*PriceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMarketPrice",
			Handler:    _Price_GetMarketPrice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// GetTradeStatisticsClient is the client API for GetTradeStatistics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GetTradeStatisticsClient interface {
	GetTradeStatistics(ctx context.Context, in *GetTradeStatisticsRequest, opts ...grpc.CallOption) (*GetTradeStatisticsReply, error)
}

type getTradeStatisticsClient struct {
	cc grpc.ClientConnInterface
}

func NewGetTradeStatisticsClient(cc grpc.ClientConnInterface) GetTradeStatisticsClient {
	return &getTradeStatisticsClient{cc}
}

func (c *getTradeStatisticsClient) GetTradeStatistics(ctx context.Context, in *GetTradeStatisticsRequest, opts ...grpc.CallOption) (*GetTradeStatisticsReply, error) {
	out := new(GetTradeStatisticsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.GetTradeStatistics/GetTradeStatistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetTradeStatisticsServer is the server API for GetTradeStatistics service.
// All implementations must embed UnimplementedGetTradeStatisticsServer
// for forward compatibility
type GetTradeStatisticsServer interface {
	GetTradeStatistics(context.Context, *GetTradeStatisticsRequest) (*GetTradeStatisticsReply, error)
	mustEmbedUnimplementedGetTradeStatisticsServer()
}

// UnimplementedGetTradeStatisticsServer must be embedded to have forward compatible implementations.
type UnimplementedGetTradeStatisticsServer struct {
}

func (UnimplementedGetTradeStatisticsServer) GetTradeStatistics(context.Context, *GetTradeStatisticsRequest) (*GetTradeStatisticsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTradeStatistics not implemented")
}
func (UnimplementedGetTradeStatisticsServer) mustEmbedUnimplementedGetTradeStatisticsServer() {}

// UnsafeGetTradeStatisticsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GetTradeStatisticsServer will
// result in compilation errors.
type UnsafeGetTradeStatisticsServer interface {
	mustEmbedUnimplementedGetTradeStatisticsServer()
}

func RegisterGetTradeStatisticsServer(s grpc.ServiceRegistrar, srv GetTradeStatisticsServer) {
	s.RegisterService(&GetTradeStatistics_ServiceDesc, srv)
}

func _GetTradeStatistics_GetTradeStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetTradeStatisticsServer).GetTradeStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.GetTradeStatistics/GetTradeStatistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetTradeStatisticsServer).GetTradeStatistics(ctx, req.(*GetTradeStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GetTradeStatistics_ServiceDesc is the grpc.ServiceDesc for GetTradeStatistics service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GetTradeStatistics_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.GetTradeStatistics",
	HandlerType: (*GetTradeStatisticsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTradeStatistics",
			Handler:    _GetTradeStatistics_GetTradeStatistics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// ShutdownServerClient is the client API for ShutdownServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShutdownServerClient interface {
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error)
}

type shutdownServerClient struct {
	cc grpc.ClientConnInterface
}

func NewShutdownServerClient(cc grpc.ClientConnInterface) ShutdownServerClient {
	return &shutdownServerClient{cc}
}

func (c *shutdownServerClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error) {
	out := new(StopReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.ShutdownServer/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShutdownServerServer is the server API for ShutdownServer service.
// All implementations must embed UnimplementedShutdownServerServer
// for forward compatibility
type ShutdownServerServer interface {
	Stop(context.Context, *StopRequest) (*StopReply, error)
	mustEmbedUnimplementedShutdownServerServer()
}

// UnimplementedShutdownServerServer must be embedded to have forward compatible implementations.
type UnimplementedShutdownServerServer struct {
}

func (UnimplementedShutdownServerServer) Stop(context.Context, *StopRequest) (*StopReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedShutdownServerServer) mustEmbedUnimplementedShutdownServerServer() {}

// UnsafeShutdownServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShutdownServerServer will
// result in compilation errors.
type UnsafeShutdownServerServer interface {
	mustEmbedUnimplementedShutdownServerServer()
}

func RegisterShutdownServerServer(s grpc.ServiceRegistrar, srv ShutdownServerServer) {
	s.RegisterService(&ShutdownServer_ServiceDesc, srv)
}

func _ShutdownServer_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShutdownServerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.ShutdownServer/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShutdownServerServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShutdownServer_ServiceDesc is the grpc.ServiceDesc for ShutdownServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShutdownServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.ShutdownServer",
	HandlerType: (*ShutdownServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Stop",
			Handler:    _ShutdownServer_Stop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// TradesClient is the client API for Trades service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradesClient interface {
	GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*GetTradeReply, error)
	TakeOffer(ctx context.Context, in *TakeOfferRequest, opts ...grpc.CallOption) (*TakeOfferReply, error)
	ConfirmPaymentStarted(ctx context.Context, in *ConfirmPaymentStartedRequest, opts ...grpc.CallOption) (*ConfirmPaymentStartedReply, error)
	ConfirmPaymentReceived(ctx context.Context, in *ConfirmPaymentReceivedRequest, opts ...grpc.CallOption) (*ConfirmPaymentReceivedReply, error)
	KeepFunds(ctx context.Context, in *KeepFundsRequest, opts ...grpc.CallOption) (*KeepFundsReply, error)
	WithdrawFunds(ctx context.Context, in *WithdrawFundsRequest, opts ...grpc.CallOption) (*WithdrawFundsReply, error)
}

type tradesClient struct {
	cc grpc.ClientConnInterface
}

func NewTradesClient(cc grpc.ClientConnInterface) TradesClient {
	return &tradesClient{cc}
}

func (c *tradesClient) GetTrade(ctx context.Context, in *GetTradeRequest, opts ...grpc.CallOption) (*GetTradeReply, error) {
	out := new(GetTradeReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/GetTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) TakeOffer(ctx context.Context, in *TakeOfferRequest, opts ...grpc.CallOption) (*TakeOfferReply, error) {
	out := new(TakeOfferReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/TakeOffer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) ConfirmPaymentStarted(ctx context.Context, in *ConfirmPaymentStartedRequest, opts ...grpc.CallOption) (*ConfirmPaymentStartedReply, error) {
	out := new(ConfirmPaymentStartedReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/ConfirmPaymentStarted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) ConfirmPaymentReceived(ctx context.Context, in *ConfirmPaymentReceivedRequest, opts ...grpc.CallOption) (*ConfirmPaymentReceivedReply, error) {
	out := new(ConfirmPaymentReceivedReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/ConfirmPaymentReceived", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) KeepFunds(ctx context.Context, in *KeepFundsRequest, opts ...grpc.CallOption) (*KeepFundsReply, error) {
	out := new(KeepFundsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/KeepFunds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradesClient) WithdrawFunds(ctx context.Context, in *WithdrawFundsRequest, opts ...grpc.CallOption) (*WithdrawFundsReply, error) {
	out := new(WithdrawFundsReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Trades/WithdrawFunds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradesServer is the server API for Trades service.
// All implementations must embed UnimplementedTradesServer
// for forward compatibility
type TradesServer interface {
	GetTrade(context.Context, *GetTradeRequest) (*GetTradeReply, error)
	TakeOffer(context.Context, *TakeOfferRequest) (*TakeOfferReply, error)
	ConfirmPaymentStarted(context.Context, *ConfirmPaymentStartedRequest) (*ConfirmPaymentStartedReply, error)
	ConfirmPaymentReceived(context.Context, *ConfirmPaymentReceivedRequest) (*ConfirmPaymentReceivedReply, error)
	KeepFunds(context.Context, *KeepFundsRequest) (*KeepFundsReply, error)
	WithdrawFunds(context.Context, *WithdrawFundsRequest) (*WithdrawFundsReply, error)
	mustEmbedUnimplementedTradesServer()
}

// UnimplementedTradesServer must be embedded to have forward compatible implementations.
type UnimplementedTradesServer struct {
}

func (UnimplementedTradesServer) GetTrade(context.Context, *GetTradeRequest) (*GetTradeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrade not implemented")
}
func (UnimplementedTradesServer) TakeOffer(context.Context, *TakeOfferRequest) (*TakeOfferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeOffer not implemented")
}
func (UnimplementedTradesServer) ConfirmPaymentStarted(context.Context, *ConfirmPaymentStartedRequest) (*ConfirmPaymentStartedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmPaymentStarted not implemented")
}
func (UnimplementedTradesServer) ConfirmPaymentReceived(context.Context, *ConfirmPaymentReceivedRequest) (*ConfirmPaymentReceivedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmPaymentReceived not implemented")
}
func (UnimplementedTradesServer) KeepFunds(context.Context, *KeepFundsRequest) (*KeepFundsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeepFunds not implemented")
}
func (UnimplementedTradesServer) WithdrawFunds(context.Context, *WithdrawFundsRequest) (*WithdrawFundsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFunds not implemented")
}
func (UnimplementedTradesServer) mustEmbedUnimplementedTradesServer() {}

// UnsafeTradesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradesServer will
// result in compilation errors.
type UnsafeTradesServer interface {
	mustEmbedUnimplementedTradesServer()
}

func RegisterTradesServer(s grpc.ServiceRegistrar, srv TradesServer) {
	s.RegisterService(&Trades_ServiceDesc, srv)
}

func _Trades_GetTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).GetTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/GetTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).GetTrade(ctx, req.(*GetTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_TakeOffer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeOfferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).TakeOffer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/TakeOffer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).TakeOffer(ctx, req.(*TakeOfferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_ConfirmPaymentStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmPaymentStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).ConfirmPaymentStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/ConfirmPaymentStarted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).ConfirmPaymentStarted(ctx, req.(*ConfirmPaymentStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_ConfirmPaymentReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmPaymentReceivedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).ConfirmPaymentReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/ConfirmPaymentReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).ConfirmPaymentReceived(ctx, req.(*ConfirmPaymentReceivedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_KeepFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeepFundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).KeepFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/KeepFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).KeepFunds(ctx, req.(*KeepFundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trades_WithdrawFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradesServer).WithdrawFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Trades/WithdrawFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradesServer).WithdrawFunds(ctx, req.(*WithdrawFundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trades_ServiceDesc is the grpc.ServiceDesc for Trades service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trades_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Trades",
	HandlerType: (*TradesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrade",
			Handler:    _Trades_GetTrade_Handler,
		},
		{
			MethodName: "TakeOffer",
			Handler:    _Trades_TakeOffer_Handler,
		},
		{
			MethodName: "ConfirmPaymentStarted",
			Handler:    _Trades_ConfirmPaymentStarted_Handler,
		},
		{
			MethodName: "ConfirmPaymentReceived",
			Handler:    _Trades_ConfirmPaymentReceived_Handler,
		},
		{
			MethodName: "KeepFunds",
			Handler:    _Trades_KeepFunds_Handler,
		},
		{
			MethodName: "WithdrawFunds",
			Handler:    _Trades_WithdrawFunds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// WalletsClient is the client API for Wallets service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WalletsClient interface {
	GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesReply, error)
	GetAddressBalance(ctx context.Context, in *GetAddressBalanceRequest, opts ...grpc.CallOption) (*GetAddressBalanceReply, error)
	GetUnusedBsqAddress(ctx context.Context, in *GetUnusedBsqAddressRequest, opts ...grpc.CallOption) (*GetUnusedBsqAddressReply, error)
	SendBsq(ctx context.Context, in *SendBsqRequest, opts ...grpc.CallOption) (*SendBsqReply, error)
	SendBtc(ctx context.Context, in *SendBtcRequest, opts ...grpc.CallOption) (*SendBtcReply, error)
	GetTxFeeRate(ctx context.Context, in *GetTxFeeRateRequest, opts ...grpc.CallOption) (*GetTxFeeRateReply, error)
	SetTxFeeRatePreference(ctx context.Context, in *SetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*SetTxFeeRatePreferenceReply, error)
	UnsetTxFeeRatePreference(ctx context.Context, in *UnsetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*UnsetTxFeeRatePreferenceReply, error)
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionReply, error)
	GetFundingAddresses(ctx context.Context, in *GetFundingAddressesRequest, opts ...grpc.CallOption) (*GetFundingAddressesReply, error)
	SetWalletPassword(ctx context.Context, in *SetWalletPasswordRequest, opts ...grpc.CallOption) (*SetWalletPasswordReply, error)
	RemoveWalletPassword(ctx context.Context, in *RemoveWalletPasswordRequest, opts ...grpc.CallOption) (*RemoveWalletPasswordReply, error)
	LockWallet(ctx context.Context, in *LockWalletRequest, opts ...grpc.CallOption) (*LockWalletReply, error)
	UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletReply, error)
}

type walletsClient struct {
	cc grpc.ClientConnInterface
}

func NewWalletsClient(cc grpc.ClientConnInterface) WalletsClient {
	return &walletsClient{cc}
}

func (c *walletsClient) GetBalances(ctx context.Context, in *GetBalancesRequest, opts ...grpc.CallOption) (*GetBalancesReply, error) {
	out := new(GetBalancesReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetAddressBalance(ctx context.Context, in *GetAddressBalanceRequest, opts ...grpc.CallOption) (*GetAddressBalanceReply, error) {
	out := new(GetAddressBalanceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetAddressBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetUnusedBsqAddress(ctx context.Context, in *GetUnusedBsqAddressRequest, opts ...grpc.CallOption) (*GetUnusedBsqAddressReply, error) {
	out := new(GetUnusedBsqAddressReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetUnusedBsqAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SendBsq(ctx context.Context, in *SendBsqRequest, opts ...grpc.CallOption) (*SendBsqReply, error) {
	out := new(SendBsqReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SendBsq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SendBtc(ctx context.Context, in *SendBtcRequest, opts ...grpc.CallOption) (*SendBtcReply, error) {
	out := new(SendBtcReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SendBtc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetTxFeeRate(ctx context.Context, in *GetTxFeeRateRequest, opts ...grpc.CallOption) (*GetTxFeeRateReply, error) {
	out := new(GetTxFeeRateReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetTxFeeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SetTxFeeRatePreference(ctx context.Context, in *SetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*SetTxFeeRatePreferenceReply, error) {
	out := new(SetTxFeeRatePreferenceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SetTxFeeRatePreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) UnsetTxFeeRatePreference(ctx context.Context, in *UnsetTxFeeRatePreferenceRequest, opts ...grpc.CallOption) (*UnsetTxFeeRatePreferenceReply, error) {
	out := new(UnsetTxFeeRatePreferenceReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/UnsetTxFeeRatePreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionReply, error) {
	out := new(GetTransactionReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) GetFundingAddresses(ctx context.Context, in *GetFundingAddressesRequest, opts ...grpc.CallOption) (*GetFundingAddressesReply, error) {
	out := new(GetFundingAddressesReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/GetFundingAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) SetWalletPassword(ctx context.Context, in *SetWalletPasswordRequest, opts ...grpc.CallOption) (*SetWalletPasswordReply, error) {
	out := new(SetWalletPasswordReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/SetWalletPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) RemoveWalletPassword(ctx context.Context, in *RemoveWalletPasswordRequest, opts ...grpc.CallOption) (*RemoveWalletPasswordReply, error) {
	out := new(RemoveWalletPasswordReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/RemoveWalletPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) LockWallet(ctx context.Context, in *LockWalletRequest, opts ...grpc.CallOption) (*LockWalletReply, error) {
	out := new(LockWalletReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/LockWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletsClient) UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletReply, error) {
	out := new(UnlockWalletReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.Wallets/UnlockWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletsServer is the server API for Wallets service.
// All implementations must embed UnimplementedWalletsServer
// for forward compatibility
type WalletsServer interface {
	GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesReply, error)
	GetAddressBalance(context.Context, *GetAddressBalanceRequest) (*GetAddressBalanceReply, error)
	GetUnusedBsqAddress(context.Context, *GetUnusedBsqAddressRequest) (*GetUnusedBsqAddressReply, error)
	SendBsq(context.Context, *SendBsqRequest) (*SendBsqReply, error)
	SendBtc(context.Context, *SendBtcRequest) (*SendBtcReply, error)
	GetTxFeeRate(context.Context, *GetTxFeeRateRequest) (*GetTxFeeRateReply, error)
	SetTxFeeRatePreference(context.Context, *SetTxFeeRatePreferenceRequest) (*SetTxFeeRatePreferenceReply, error)
	UnsetTxFeeRatePreference(context.Context, *UnsetTxFeeRatePreferenceRequest) (*UnsetTxFeeRatePreferenceReply, error)
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionReply, error)
	GetFundingAddresses(context.Context, *GetFundingAddressesRequest) (*GetFundingAddressesReply, error)
	SetWalletPassword(context.Context, *SetWalletPasswordRequest) (*SetWalletPasswordReply, error)
	RemoveWalletPassword(context.Context, *RemoveWalletPasswordRequest) (*RemoveWalletPasswordReply, error)
	LockWallet(context.Context, *LockWalletRequest) (*LockWalletReply, error)
	UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletReply, error)
	mustEmbedUnimplementedWalletsServer()
}

// UnimplementedWalletsServer must be embedded to have forward compatible implementations.
type UnimplementedWalletsServer struct {
}

func (UnimplementedWalletsServer) GetBalances(context.Context, *GetBalancesRequest) (*GetBalancesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalances not implemented")
}
func (UnimplementedWalletsServer) GetAddressBalance(context.Context, *GetAddressBalanceRequest) (*GetAddressBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressBalance not implemented")
}
func (UnimplementedWalletsServer) GetUnusedBsqAddress(context.Context, *GetUnusedBsqAddressRequest) (*GetUnusedBsqAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnusedBsqAddress not implemented")
}
func (UnimplementedWalletsServer) SendBsq(context.Context, *SendBsqRequest) (*SendBsqReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBsq not implemented")
}
func (UnimplementedWalletsServer) SendBtc(context.Context, *SendBtcRequest) (*SendBtcReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBtc not implemented")
}
func (UnimplementedWalletsServer) GetTxFeeRate(context.Context, *GetTxFeeRateRequest) (*GetTxFeeRateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxFeeRate not implemented")
}
func (UnimplementedWalletsServer) SetTxFeeRatePreference(context.Context, *SetTxFeeRatePreferenceRequest) (*SetTxFeeRatePreferenceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTxFeeRatePreference not implemented")
}
func (UnimplementedWalletsServer) UnsetTxFeeRatePreference(context.Context, *UnsetTxFeeRatePreferenceRequest) (*UnsetTxFeeRatePreferenceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsetTxFeeRatePreference not implemented")
}
func (UnimplementedWalletsServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedWalletsServer) GetFundingAddresses(context.Context, *GetFundingAddressesRequest) (*GetFundingAddressesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFundingAddresses not implemented")
}
func (UnimplementedWalletsServer) SetWalletPassword(context.Context, *SetWalletPasswordRequest) (*SetWalletPasswordReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWalletPassword not implemented")
}
func (UnimplementedWalletsServer) RemoveWalletPassword(context.Context, *RemoveWalletPasswordRequest) (*RemoveWalletPasswordReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveWalletPassword not implemented")
}
func (UnimplementedWalletsServer) LockWallet(context.Context, *LockWalletRequest) (*LockWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockWallet not implemented")
}
func (UnimplementedWalletsServer) UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockWallet not implemented")
}
func (UnimplementedWalletsServer) mustEmbedUnimplementedWalletsServer() {}

// UnsafeWalletsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WalletsServer will
// result in compilation errors.
type UnsafeWalletsServer interface {
	mustEmbedUnimplementedWalletsServer()
}

func RegisterWalletsServer(s grpc.ServiceRegistrar, srv WalletsServer) {
	s.RegisterService(&Wallets_ServiceDesc, srv)
}

func _Wallets_GetBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetBalances(ctx, req.(*GetBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetAddressBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetAddressBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetAddressBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetAddressBalance(ctx, req.(*GetAddressBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetUnusedBsqAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnusedBsqAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetUnusedBsqAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetUnusedBsqAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetUnusedBsqAddress(ctx, req.(*GetUnusedBsqAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SendBsq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBsqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SendBsq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SendBsq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SendBsq(ctx, req.(*SendBsqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SendBtc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBtcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SendBtc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SendBtc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SendBtc(ctx, req.(*SendBtcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetTxFeeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxFeeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetTxFeeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetTxFeeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetTxFeeRate(ctx, req.(*GetTxFeeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SetTxFeeRatePreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTxFeeRatePreferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SetTxFeeRatePreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SetTxFeeRatePreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SetTxFeeRatePreference(ctx, req.(*SetTxFeeRatePreferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_UnsetTxFeeRatePreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsetTxFeeRatePreferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).UnsetTxFeeRatePreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/UnsetTxFeeRatePreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).UnsetTxFeeRatePreference(ctx, req.(*UnsetTxFeeRatePreferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_GetFundingAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFundingAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).GetFundingAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/GetFundingAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).GetFundingAddresses(ctx, req.(*GetFundingAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_SetWalletPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetWalletPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).SetWalletPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/SetWalletPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).SetWalletPassword(ctx, req.(*SetWalletPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_RemoveWalletPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveWalletPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).RemoveWalletPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/RemoveWalletPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).RemoveWalletPassword(ctx, req.(*RemoveWalletPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_LockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).LockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/LockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).LockWallet(ctx, req.(*LockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallets_UnlockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletsServer).UnlockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.Wallets/UnlockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletsServer).UnlockWallet(ctx, req.(*UnlockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Wallets_ServiceDesc is the grpc.ServiceDesc for Wallets service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Wallets_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.Wallets",
	HandlerType: (*WalletsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBalances",
			Handler:    _Wallets_GetBalances_Handler,
		},
		{
			MethodName: "GetAddressBalance",
			Handler:    _Wallets_GetAddressBalance_Handler,
		},
		{
			MethodName: "GetUnusedBsqAddress",
			Handler:    _Wallets_GetUnusedBsqAddress_Handler,
		},
		{
			MethodName: "SendBsq",
			Handler:    _Wallets_SendBsq_Handler,
		},
		{
			MethodName: "SendBtc",
			Handler:    _Wallets_SendBtc_Handler,
		},
		{
			MethodName: "GetTxFeeRate",
			Handler:    _Wallets_GetTxFeeRate_Handler,
		},
		{
			MethodName: "SetTxFeeRatePreference",
			Handler:    _Wallets_SetTxFeeRatePreference_Handler,
		},
		{
			MethodName: "UnsetTxFeeRatePreference",
			Handler:    _Wallets_UnsetTxFeeRatePreference_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _Wallets_GetTransaction_Handler,
		},
		{
			MethodName: "GetFundingAddresses",
			Handler:    _Wallets_GetFundingAddresses_Handler,
		},
		{
			MethodName: "SetWalletPassword",
			Handler:    _Wallets_SetWalletPassword_Handler,
		},
		{
			MethodName: "RemoveWalletPassword",
			Handler:    _Wallets_RemoveWalletPassword_Handler,
		},
		{
			MethodName: "LockWallet",
			Handler:    _Wallets_LockWallet_Handler,
		},
		{
			MethodName: "UnlockWallet",
			Handler:    _Wallets_UnlockWallet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// GetVersionClient is the client API for GetVersion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GetVersionClient interface {
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionReply, error)
}

type getVersionClient struct {
	cc grpc.ClientConnInterface
}

func NewGetVersionClient(cc grpc.ClientConnInterface) GetVersionClient {
	return &getVersionClient{cc}
}

func (c *getVersionClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionReply, error) {
	out := new(GetVersionReply)
	err := c.cc.Invoke(ctx, "/io.bisq.protobuffer.GetVersion/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetVersionServer is the server API for GetVersion service.
// All implementations must embed UnimplementedGetVersionServer
// for forward compatibility
type GetVersionServer interface {
	GetVersion(context.Context, *GetVersionRequest) (*GetVersionReply, error)
	mustEmbedUnimplementedGetVersionServer()
}

// UnimplementedGetVersionServer must be embedded to have forward compatible implementations.
type UnimplementedGetVersionServer struct {
}

func (UnimplementedGetVersionServer) GetVersion(context.Context, *GetVersionRequest) (*GetVersionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedGetVersionServer) mustEmbedUnimplementedGetVersionServer() {}

// UnsafeGetVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GetVersionServer will
// result in compilation errors.
type UnsafeGetVersionServer interface {
	mustEmbedUnimplementedGetVersionServer()
}

func RegisterGetVersionServer(s grpc.ServiceRegistrar, srv GetVersionServer) {
	s.RegisterService(&GetVersion_ServiceDesc, srv)
}

func _GetVersion_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetVersionServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.bisq.protobuffer.GetVersion/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetVersionServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GetVersion_ServiceDesc is the grpc.ServiceDesc for GetVersion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GetVersion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.bisq.protobuffer.GetVersion",
	HandlerType: (*GetVersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _GetVersion_GetVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}
